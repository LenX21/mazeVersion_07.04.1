import string


import re



def first_word(text: str) -> str:
    return re.search("([\w']+)", text).group(1)


def second_attempt(text: str) -> str:
    for char in ',.':
        text = text.replace(char, ' ').strip()
    text = text.split(' ')
    return text[0]
def findOccurrence(word: list) -> str:
    occurrence = None
    try:
        firstPlace = word[0].index(word[1])
        occurrence = word[0].index(word[1], firstPlace+1)
    except ValueError:
        pass
    print(occurrence)
    return occurrence

def betweenMarkers(text: str, symbolStart: str, symbolEnd: str) -> str:
    """
    :param text:
    :param symbolstart:
    :param symbolEnd:
    :return:

    You are given a string and two markers (the initial and final).
    You have to find a substring enclosed between these two markers. But there are a few important conditions:
    """

    try:
        first = text.index(symbolStart) + len(symbolStart)
    except ValueError:
        first = 0
    try:
        last = text.index(symbolEnd)
    except ValueError:
        last = len(text)

    print(text[first:last])

def bestStock(best_stock: dict):

    print (max(best_stock, key=best_stock.get))


def getItem(dictName: dict, keysName: str):
    return dictName[keysName]

def allwords(text: str, popwords: list):

    allwords = text.strip().split(' ')
    print(allwords)
    allword2 = []
    allword4 = {}

    for i in allwords:
        if i.isalpha():
            allword2.append(i)

    allword3 = [ items.lower().splitlines() for items in text.strip().lower().split(' ') if items.isalpha() ]
    print(allword3)
    for i in popwords:
        allword4[i] = allword3.count(i)

    print(allword4)

    allword5 = {key: allword3.count(key) for key in popwords}
    import json
    print(allword5)
    print(json.dumps(allword5, indent=4))

def popular_words(text: str, words: list) -> dict:

    allwords = [ items.lower() for items in text.replace('\n', ' ').strip().split(' ') ]
    result = {key: allwords.count(key) for key in words}
    return result


def biggerPrice(amount: int, items: list):
    result = sorted(items, key= lambda x: x['price'], reverse=True)
    print(result[0:amount])

def mostNumbers(*args):
    """
    Input: An arbitrary number of arguments as numbers (int, float).
    Output: The difference between maximum and minimum as a number (int, float).
    :return:
    """
    try:
        result = max(args) - min(args)
    except ValueError:
        result = 0

    print(round(result, 1))

def evenTheLast(numbers: list):
    """
    You should find the sum of the elements with even indexes (0th, 2nd, 4th...)
    then multiply this summed number and the final element of the array together.
    :param numbers:
    :return:
    """
    result = 0
    print(len(numbers))
    if len(numbers) > 0:
        result = sum(numbers[0::2])*numbers[-1]
    print(f'Result {result}')

def secretMessage(text: str):
    """
    You are given a chunk of text.
    Gather all capital letters in one word in the order that they appear in the text.
    :param text:
    :return:
    """
    result = [x for x in text if x.isupper()]
    return ''.join(result)


def threeWords_test1(text: str):
    """
    You are given a string with words and numbers separated by whitespaces (one space).
    The words contains only letters. You should check if the string contains three words in succession.
    For example, the string "start 5 one two three 7 end" contains three words in succession.
    :param text:
    :return:
    """
    newtext = text.split(" ")
    counter = 0
    result = False
    while counter < len(newtext)-2 and len(newtext) >= 3:
        result = ''.join(newtext[counter:counter+3]).isalpha()
        if result:
            break
        counter += 1
    print(result)

def threeWords(text: str):
    """
    You are given a string with words and numbers separated by whitespaces (one space).
    The words contains only letters. You should check if the string contains three words in succession.
    For example, the string "start 5 one two three 7 end" contains three words in succession.

    :param text:
    :return:
    """
    newtext = text.split(" ")
    counter = 0
    for x in newtext:
        if x.isalpha():
            counter += 1
            if counter >= 3:
                return True
        else:
            counter = 0
    return False

def indexPower(arrayL: list, indexI: int):
    """
    You are given an array with positive numbers and a number N.
    You should find the N-th power of the element in the array with the index N.
    If N is outside of the array, then return -1.
    Don't forget that the first element has the index 0.

    :param arrayL:
    :param indexI:
    :return:
    """
    try:
        return pow(arrayL[indexI], indexI)
    except IndexError:
        return -1
def rightToLeft(instructions: set):
    """
    You are given a sequence of strings.
    You should join these strings into chunk of text where the initial strings are separated by commas.
    As a joke on the right handed robots, you should replace all cases of the words "right" with the word "left",
    even if it's a part of another word. All strings are given in lowercase.
    :param instructions:
    :return:
    """
    return (','.join(instructions).replace('right', 'left'))

def digitsMultiplication_1(num: int):

    newInt = [x for x in str(num) if x != '0']
    result = 1
    for x in newInt:
        result = int(x)*result
    print(result)

def digitsMultiplication(num: int):
    result = 1
    for y in str(num):
        if y == '0': continue
        result = result * int(y)
    print(result)

def absoluteSorting(array: set):
    print(sorted(array, key = lambda x: x*(-1) if x < 0 else x ))

def theMostFrequent(array: list):
    """
        determines the most frequently occurring string in the sequence.
    """
    print(sorted(array, key= lambda e: array.count(e), reverse=True)[0])
    print(sorted(array.count(e) for e in array)[0])

def easyUnpack(array: set):
    """
    Your mission here is to create a function that gets an tuple
    and returns a tuple with 3 elements - first, third and second
    to the last for the given array

    :param array:
    :return:
    """
    return array[0], array[2], array[len(array)-2]

def baseNumbers(item: str, radix: int):
    try:
        return int(item, radix)
    except ValueError:
        return -1



if __name__ == '__main__':
    #first_word("Text,!! with!! punctuations")
    #second_attempt("greetings, friends")
    #findOccurrence(['sims', ' '])
    #betweenMarkers ("<head><title>My new site</title></head>", "<title>", "</title>")

    #bestStock({
    #'CAC': 10.0,
    #'ATX': 390.2,
    #'WIG': 1.2})
    #allwords('''
    #When I was One
    #I had just begun
    #When I was Two
    #I was nearly new
    #''', ['i', 'was', 'three', 'near'])

    #biggerPrice(1, [{"name": "water", "price": 1}, {"name": "wine", "price": 138}])
    #mostNumbers()
    #evenTheLast([])
    #assert secretMessage("How are you? Eh, ok. Low or Lower? Ohhh.") == "HELLO", "hello"
    #assert threeWords("Hello World hello") == True
    threeWords('Hi')
    assert indexPower([1, 2], 3) == -1
    assert rightToLeft(("left", "right", "left", "stop")) == "left,left,left,stop", "All to left"
    digitsMultiplication(123405)
    absoluteSorting((-1, 2, -3, 0))
    theMostFrequent(['a', 'a', 'bi', 'bi', 'bi', '7', '7', '7', '7'])
    assert easyUnpack((1, 2, 3, 4, 5, 6, 7, 9)) == (1,3,7)
    assert baseNumbers("Z", 36) == 35
    assert baseNumbers("AB", 10) == -1
    assert baseNumbers("AF", 16) == 175

